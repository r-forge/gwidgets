\documentclass[12pt]{article}
\newcommand{\VERSION}{X.X.X}
%\VignetteIndexEntry{gWidgets}
%\VignettePackage{gWidgets}
%\VignetteDepends{methods}

\usepackage{times}              % for fonts
\usepackage[]{geometry}
\usepackage{mathptm}            % for math fonts type 1
\usepackage{graphicx}           % for graphics files
%%\usepackage{floatflt}           % for ``floating boxes''
%%\usepackage{index}
\usepackage{relsize}            % for relative size fonts
\usepackage{amsmath}            % for amslatex stuff
\usepackage{amsfonts}           % for amsfonts
\usepackage{url}                % for \url,
\usepackage{hyperref}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
%%\usepackage{jvfloatstyle}       % redefine float.sty for my style. Hack


%% squeeze in stuff
%%\floatstyle{jvstyle}
%%\restylefloat{table}
%%\restylefloat{figure}
%%\renewcommand\floatpagefraction{.9}
\renewcommand\topfraction{.9}
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}
\setcounter{totalnumber}{50}
\setcounter{topnumber}{50}
\setcounter{bottomnumber}{50}

%% Fill these in
\pagestyle{fancy}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\code{gWidgets}}
\fancyhead[C]{}
\fancyhead[R]{\sectionmark}
\fancyfoot[L]{}
\fancyfoot[C]{- page \thepage\/ -}
\fancyfoot[R]{}
\renewcommand{\headrulewidth}{0.1pt}
\renewcommand{\footrulewidth}{0.0pt}

%% My abbreviations
\newcommand{\pkg}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\RFunc}[1]{\code{#1}} %% no ()
\newcommand{\RArg}[1]{\code{#1=}}
\newcommand{\RListel}[1]{\code{\$#1}}
\newcommand{\R}{\texttt{R}}

\newenvironment{RArgs}{\begin{list}{}{}}{\end{list}}


\begin{document}
\thispagestyle{plain}
\title{gWidgetsWWW}

\author{John Verzani, \url{gWidgets@gmail.com}}
\maketitle

%% Sweave stuff
\SweaveOpts{keep.source=TRUE}

\section*{Abstract:}
The \pkg{gWidgets} package provides a programming interface to write
graphical user interfaces from within R. The API trades off power for
relative simplicity and has proven useful for writing small to
moderately complicated GUIs. This package \pkg{gWidgetsWWW2}
implements much of the API for programming GUIs for the web. It uses
the Ext JS JavaScript libraries (\url{(www.sencha.com}) to provide the
toolkit and the \pkg{Rook} package of Jeffrey Horner to integrate with
\R's local web server or \pkg{rapache}, for serving page to a public
audience.

As the name suggests, this is the second version of the
implementation. This one uses \R's reference classes internally,
although the programmer never need know this.

%\setcounter{tocdepth}{3}
%\tableofcontents

\section{Overview}

A modern set of web tools includes three primary domains: HTML for
markup of the text, CSS for the layout of the page, and JavaScript to
manipulate the page. This package requires none of these, as it
leverages a popular javascript library (ext from \url{www.sencha.com})
to provide a consistent look (the CSS part) and the javascript interactivity. As the
pages are not centered around displaying content, but rather
interactive controls, there is no need for HTML knowledge. However, if
desired, the package can be used to integrate in with an existing web
page.

To make a GUI in \pkg{gWidgets} requires two steps: writing a script
and calling that script.

A simple script could look like:
\begin{Sinput}
w <- gwindow("simple GUI with one button", visible=FALSE)
g <- ggroup(cont = w)
b <- gbutton("click me", cont = g, handler = function(h,...) {
  gmessage("hello world", parent = b)
})
visible(w) <- TRUE
\end{Sinput}

The script can be run through a specific URL which is created when the
\code{load\_app} command is executed. For example, if the script above
is stored as \code{hello.R}, then this call will open the page:
<<eval=FALSE>>=
load_app("hello.R", app_name="HelloApp")
@ 


GUIs made with gWidgetsWWW are not as snappy as other web GUIs. The
main reason for this is the fact that callbacks to manipulate the page
are sent back into R (the server) and then returned. In many GUIs,
this is avoided by using javascript directly on the web page. The
clear tradeoff is ease of programming for the R user (R not
javascript) versus speed for the user.


The package provides some documentation of its main functions. The
\pkg{gWidgets} package has more, but there are many additional
\pkg{gWidgetsWWW2} specific arguments to the constructors, so the
package documentation needs to be looked at.

\section{Top level windows}

Web GUIs are different than desktop GUIs. Not only are they slower, as
they have lag time between the GUI and the server, there can only be
one top-level window. This is a \code{gwindow} instance called without
a \code{parent} argument.
  
Other \code{gwindow} instances are either a) subwindows (appearing as
a separate window) if the argument \code{renderTo} is not specified of
b) rendered to the DOM element with id specified by
\code{renderTo}. The latter allows \pkg{gWidgetsWWW2} to integrate
with other web pages. Within a page, leave a tag, such as
\verb+<div id="some_id"></div>+ and then pass the argument
\code{renderTo="some\_id"} to the constructor. The \code{ex-multiple}
example demonstrates.
  





\section{The containers}
\label{sec:containers}

The \pkg{gWidgetsWWW} package has all the following containers the
top-level container \code{gwindow}, subwindows also constructed
through \code{gwindow} (use a parent object); the box
containers\code{ggroup}, \code{gframe} and \code{gexpandgroup}; the
tabular layout container \code{glayout}; the notebook container
\code{gnotebook}, and \code{gpanedgroup}.

To make a component appear in response to some action -- such as
happens with gexpandgroup, one can add it to a box container
dynamically. Or one can put it in a \code{ggroup} instance and toggle
that containers visibility with the \code{visible} method, in a manner
identical to how \code{gexpandgroup} is used.

The containers in \pkg{gWidgetsWWW} may need to have their sizes fixed
to have them render as desired. The constructors have arguments
\code{width} and \code{height} for specifying the initial width and
height. These take values in numbers of pixels, or the character
string \code{"auto"}, for automatic sizing by the layout mechanism of ExtJS.

\section{The widgets}
\label{sec:what-works}

Most -- but not all -- of the standard widgets work as expected. This
includes labels (\code{glabel}), buttons (\code{gbutton}), radio
buttons (\code{gradio}), checkboxes (\code{gcheckbox},
\code{gcheckboxgroup}), comboboxes (\code{gcombobox}), sliders
(\code{gslider}), spinboxes (well kind of) (\code{gspinbutton}),
single-line edit boxes (\code{gedit}), multi-line text areas
(\code{gtext}), dataframe viewers (\code{gtable}) and editors
(\code{gdf}), images (\code{gimage} -- the image is a url), menu bars
(\code{gmenu} -- but not toolbars), and statusbars (\code{gstatusbar}).

The dialogs (except \code{gbasicdialog}) are implemented. Just use a subwindow for that functionality.

The widgets \code{galert}, \code{ghtml} and \code{gaction} are all
implemented.

The \code{gtree} widget is implemented, but only has one column for
display -- not a grid.


No attempt has been made to include the compound widgets
\code{gvarbrowser}, \code{ggenericwidget}, \code{gdfnotebook},
\code{ggraphicsnotebook}.

The \code{ghelp} constructor is not provided. The \pkg{helpr} package
is very useful for that.


\subsection{graphics}
\label{sec:graphics}

There is no \textit{interactive} plot device. Rather one can use a
variety of non-interactive devices and an accompanying widget.

These include:
\begin{itemize}
\item  the \pkg{canvas} device along with the \code{gcanvas} widget. This device writes out JavaScript commands and uses an underlying canvas object on the web page. This requires an HTML5 compliant browser. There is some support for mouse events.
\item The \code{gsvg} widget can be used to display svg graphics, as produced by the \code{svg} driver or the \pkg{RSVGTipsDevice} driver.
\item The \code{gimage} widget can be used to display graphics produced by the \code{png} driver, among others.
\end{itemize}

Both the last two require both a file and a url, the file to write to,
the url to use by the browser. If the file is created by
\code{get\_tempfile} the details are implemented by the widget.

The \code{gcanvas} device is used like a non-interactive device (open
the device, create the graphic, call \code{dev.off()}). The widget it
provides responds to mouse clicks through a handler specified with
\code{addHandlerClicked}. The ``h'' argument is a list with additional
components \code{x} and \code{y} (containing the ndc coordinates of
the point with $(0,0)$ being the lower left corner) and \code{X} and
\code{Y} (containing the pixel coordinates of the click, with $(0,0)$
being the upper left corner. The \code{x} and \code{y} values can be
converted into \code{user} coordinates through \code{grconvertXY}, but
there is a catch -- the device needs to be reopened with the same
dimensions, as that information is lost when the device is closed. See
the example \code{ex-gcanvas} for an illustration.


\subsection{ggooglemaps}
\label{sec:ggooglemaps}

The \code{ggooglemaps} widget provides access to a sliver of the
google maps API.  The \code{load\_app} method has an argument to
indicate this will be used, as otherwise the google libraries need not
be loaded.


\subsection{Ext}

The underlying constructors and handlers basically do just one thing:
write out JavaScript code for the \code{ExtJS} libraries to interpret
at the browser. Some features allow one to do this directly, if desired.

First, the constructors have the argument \code{ext.args} to specify
additional arguments to the \code{Ext} constructor. These are
specified through a named list and the package will do a conversion to
a JavaScript object.

Next, the objects have a few methods. The \code{call\_Ext} method
takes a method name and other arguments and calls the corresponding
\code{Ext} method. The arguments are coerced from \R\/ objects. For
example, if \code{b} is a \code{gbutton} instance, then
\code{b\$call\_Ext("setVisible", FALSE)} will adjust the visibility of
the widget. (As will the call \code{visible(b) = FALSE}, in this
example.). The method \code{ext\_apply} will merge configuration
values from list.

The method \code{add\_js\_queue} allows one to pass arbitrary
JavaScript calls to the browser. This queue is flushed when the client
browser makes a request of the server, such as when a callback is
being processed.

\subsection{Data persistence}
\label{sec:data-persistence}

AJAX technologies are used to prevent a page load every time a request
is made of the server, but each time a page is loaded a new R session
is loaded. Any variables stored in a previous are forgotten. To keep
data persistent across pages, one can load and write data to a file or
a data base.




\subsection{Quirks}
\label{sec:quirks}

A number of little quirks are present, that are not present with other \pkg{gWidgets} implementations:
\begin{description}
\item[Top-level windows] There can be only one top-level window (one
  without a parent container).
\item[Data transport] The interface between the browser and R is
  one-way only. There is (currently) no means for the R process to
  query the state of the browser. As such, to synchronize, an AJAX
  call is made back to the R process when each widget is updated. We
  call this \code{transport} and for the most part it works as
  expected. There are times where it gets confused.
\item[Environment of handlers] Each page is loaded in a different
  environment, so as not to interfere with th
  e users workspace. This
  environment is created when the page is loaded and persists until it
  is closed.
\item[Debugging woes] Debugging can be tough as the R session is not readily
  available. The error messages in the browser are useful. For
  development of the package the firebug (\url{getfirebug.com}) add on
  to FireFox has proven very useful. Alternatively, it can be helpful
  to source in the script at the command line to see if there are errors.
\item[\code{sapply}] If one calls \code{sapply} and returns widgets
  and error will occur. This is due to the \code{length} method of the
  widget interfering with the base \code{length} function in the call
  to \code{simplify2array}. To work around that use \code{lapply}.
\end{description}




\section{Installation}
The local usage is configured when the package is installed. After
installation typing \code{demo(gWidgetsWWW2)} should open a page
allowing the examples to be run.

At this point the package needs to be intergrated in with
\pkg{rapache} to serve pages to the public.


% \section{Security}
% \label{sec:security}

% Security -- is a big deal. Web servers can be hacked, and if hacked
% the hacker has full access to the server. This can be scary. The local
% server blocks all requests that are not to the local IP 127.0.0.1,
% preventing outside access. As for outside access, although it is not
% believed that RApache is any less secure than other Apache modules,
% you can protect yourself by running the entire setup within a virtual
% machine. There is easy to install, reasonably priced (or free)
% commercial software from VMWare (\url{www.vmware.com}). For
% open-source fans, the VirtualBox project (\url{www.virtualbox.org})
% also has software. One can install this, then run the author provided
% appliance. Or one can install the virtual software, install a host OS
% (ubuntu linux say), then install Apache and R then RApache etc. It
% actually isn't so hard to do.

% The call from the web server back into RApache can also be source of
% insecurity. The \pkg{gWidgetsWWW} package allows only a limited number
% of calls back from a web page, which should in theory be secure. But
% if the script is not secure, there is nothing the package can
% do. Scripts must \textit{never} trust that data sent from the web page
% to the server is safe. It should be coerced into any desired format,
% and never evaluated. Using \code{eval} say allows any one to run R
% commands on the server which given the power of R means they have full
% control of the server.

% The web server communicates back to the web browser through an AJAX
% call. This is supposed to be secure, as only javascript code that
% originates from the same server as the initial page is executed.

\end{document}
