##      Copyright (C) 2011  John Verzani
##  
##      This program is free software: you can redistribute it and/or modify
##      it under the terms of the GNU General Public License as published by
##      the Free Software Foundation, either version 3 of the License, or
##      (at your option) any later version.
##  
##      This program is distributed in the hope that it will be useful,
##      but WITHOUT ANY WARRANTY; without even the implied warranty of
##      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##      GNU General Public License for more details.
##  
##      You should have received a copy of the GNU General Public License
##      along with this program.  If not, see <http://www.gnu.org/licenses/>.

##' @include ext-widget.R
NA

##' Widget containing a canvas element.
##'
##' Primarily this is a widget meant to hold a graphic produced by the
##' \pkg{canvas} package device direct.  This package provides a
##' non-interactive device for creating graphic files using
##' JavaScript. This widget allows such files to be displayed easily.
##' However, one can also write low-level canvas methods to the device if desired.
##' When used with the \pkg{canvas} package, one passes to the
##' constructor or the \code{svalue<-} method a function that has been
##' used by the \code{canvas} device driver to store the JavaScript
##' commands representing the graphic. The basic use is in an example
##' below.
##' The canvas widget can listen for mouse events, notably the click event.
##' The first argument list for the callback passed to
##' \code{addHandlerClicked} has additional components \code{x,y}
##' containing the position of the click in ndc coordinates (in [0,1]
##' with (0,0) being lower left; \code{X,Y} the pixel position of the
##' click with (0,0) being the upper left corner; and \code{width,
##' height} containing the width and height of the canvas widget (also
##' passed in to the constructor, but this makes things convenient).
##' Conversion from ndc to "user" coordinates is done with \code{grconvertXY}, but
##' there is a catch, as one must call this with an active device.
##' The low level canvas command allow one to draw on the canvas using
##' the pixel coordinates, which are passed back as \code{X} and
##' \code{Y}. The pixel coordinates use (0,0) as the upper right. A
##' demo shows how the low level commands can be used with the mouse
##' motion handlers to create a GUI where an element can be dragged
##' around. It isn't as responsive as one would hope, as the callback
##' into R from the browser has too much lag.
##' @param f Optional. A file name containing output generated by the \code{canvas} device.
##' @param width width of widget in pixels
##' @param height height of widget in pixels
##' @param container parent container
##' @param ... passed to add method of container
##' @return an \code{ExtWidget} object
##' @note  In the
##' click handler one gets passed the click coordinate in ndc
##' coordinates, as this is the best the JavaScript can do, not
##' knowing the device parameters. When R gets this back it doesn't
##' have the current device to call \code{grconvertX}, say, so one
##' needs to hack in a call to the canvas device to reset the
##' parameters. See the demo examples. The examples here are more basic.
##' @export
##' @examples
##' w <- gwindow()
##' gstatusbar("Powered by gWidgetsWWW2 and Rook", cont=w)
##' 
##' width <- height <- 250
##' f <- tempfile()
##' canvas(f, width=width, height=height)
##' hist(rnorm(100))
##' dev.off()
##' cnv <- gcanvas(f, container=w, width=width, height=height)
##' ## make a new new graphic
##' gbutton("refresh", cont=w, handler=function(h,...) {
##'   f <- svalue(cnv)
##'   canvas(f, width=width, height=height)
##'   hist(rnorm(100))
##'   dev.off()
##'   svalue(cnv) <- f
##' })
##'
##' ## Using canvas for drawing area using lower level canvas methods
##' w <- gwindow("gcanvas example")
##' sb <- gstatusbar("Powered by gWidgetsWWW2 and Rack", cont=w)
##' g <- ggroup(cont=w, horizontal=FALSE)
##' width <- 500; height <- 500
##' 
##' cnv <- gcanvas(width=width, height=height, cont=g)
##' 
##' started <-FALSE
##' cnv$add_handler_mouse_down(handler=function(h,...) {
##'   cnv$call_method("beginPath")
##'   cnv$call_method("moveTo", h$X, h$Y)
##'   started <<- TRUE
##' })
##' 
##' 
##' cnv$add_handler_mouse_move(handler=function(h,...) {
##'   if(started) {
##'     cnv$call_method("lineTo", h$X, h$Y)
##'     cnv$call_method("stroke")
##'   }
##' })
##' 
##' cnv$add_handler_mouse_up(handler=function(h,...) {
##'   started <<- FALSE
##' })
gcanvas <- function(f=NULL, width=480, height=400,
                    container = NULL,...) {
  cnv <- GCanvas$new(container$toplevel)
  cnv$init(f,  width, height, container, ...)
  return(cnv)
}

##' class for gcanvas
##' @name gcanvas-class
GCanvas <- setRefClass("GCanvas",
                       contains="ExtWidget",
                       fields=list(
                         "f" = "ANY",   # name of file
                         "width" = "numeric",
                         "height" = "numeric"
                         ),
                       methods=list(
                         init = function(f,
                           width=480, height=400,
                           container,
                           ...,
                           ext.args=NULL) {
                           
                           width <<- getWithDefault(width, 480)
                           height <<- getWithDefault(height, 400)

                           constructor <<- "Ext.Panel"
                           arg_list <- list(border = TRUE,
                                            hideBorders = FALSE,
                                            html = sprintf("<canvas id='%s' width='%s' height='%s' style='position:\"absolute\"'>%s</canvas>",
                                              get_canvas_id(),
                                              .self$width, .self$height,
                                              gettext("If you see this, your browser does not support the canvas tag")),
                                            width = .self$width,
                                            height = .self$height,
                                            tooltip = getFromDots("tooltip", ...)
                                            )

                           add_args(arg_list)
                           
                           if(!is.null(ext.args))
                             args$extend(ext.args)
                           
                           container$add_dots(.self, ...)                           

                           write_constructor()


                           ## no handler, so we add here
                           container$add(.self, ...)

                           ## write JavaScript to define context
                           cmd <- sprintf("var %s = document.getElementById('%s').getContext('2d');",
                                          get_canvas_context(), get_canvas_id())
                           add_js_queue(cmd)

                           
                           if(!missing(f) && !is.null(f))
                             set_value(f)

                           .self
                         },
                         ## main property
                         get_value = function() {
                           "Return f"
                           f
                         },
                         ## Special clear argument
                         set_value = function(value, clear=TRUE, ...) {
                           "Set f, send out plot commands"
                           f <<- value
                           if(!file.exists(f)) return()
                           
                           x <- readLines(f, warn=FALSE)
                           if(length(x)) {
                             cmd <- sprintf("var ctx = document.getElementById('%s').getContext('2d');", get_canvas_id())

                             add_js_queue(cmd)
                             if(clear) {
                               cmd <- sprintf("ctx.clearRect(0,0,%s,%s);", width, height)
                               add_js_queue(cmd)
                             }
                             sapply(x[-1], add_js_queue) # first line is a comment
                           }
                           },
                         
                         ##
                         get_canvas_id = function() {
                           "return ID of canvas object withing panel"
                           sprintf("%s_canvas", id)
                         },
                         get_canvas_context = function() {
                           "Return variable name for canvas context"
                           sprintf("%s_context", get_canvas_id())
                         },
                         ## handlers
                         add_R_callback = function(signal, callback, action, cb_args, param_defn ="var params={}") {
                           "Override of R callback function, as canvas is different"
                           cbid <- toplevel$add_R_handler(.self, callback, action)
                           cmd <- paste(sprintf("var ctx = document.getElementById('%s');", get_canvas_id()),
                                        sprintf("ctx.addEventListener('%s', function(%s) {%s;callRhandler(%s, params)},false);",
                                                signal,
                                                paste(cb_args, collapse=","),
                                                param_defn,
                                                cbid),
                                        sep="")
                           add_js_queue(cmd)
                           list(cbid=cbid)
                         },
                         get_event_params = function() {
                           "Helper to set params to pass from event"
                           ## what is right position? seems like offset should be x,y values
                           ## offset not supported in opera?
                           params <- paste("var x = e.offsetX ? e.offsetX : e.layerX;",
                                           "var y = e.offsetY ? e.offsetY : e.layerY;",
                                           "var w = this.width; var h=this.height;",                                         
                                           "var ndcX = x/w; var ndcY = (h - y)/h;",
                                           "var params = {x:ndcX, y:ndcY, X:x, Y:y, lx:e.layerX, ly:e.layerY, px:e.pageX, py: e.pageY, cx:e.clientX, cy: e.clientY, ox: e.offsetX, oy: e.offsetY, width:this.width, height:this.height};",
                                           sep="")
                           params
                         },
                         ## some basic event listeners
                         add_handler_clicked = function(handler, action=NULL, ...) {
                           ## Not good for all browsers
                           add_R_callback("click", handler, action, cb_args="e", param_defn=get_event_params())
                         },
                         add_handler_mouse_motion = function(handler, action=NULL, ...) {
                           add_R_callback("mouseover", handler, action, cb_args="e", param_defn=get_event_params())
                         },
                         add_handler_mouse_down = function(handler, action=NULL, ...) {
                           add_R_callback("mousedown", handler, action, cb_args="e", param_defn=get_event_params())
                         },
                         add_handler_mouse_move = function(handler, action=NULL, ...) {
                           add_R_callback("mousemove", handler, action, cb_args="e", param_defn=get_event_params())
                         },
                         add_handler_mouse_up = function(handler, action=NULL, ...) {
                           add_R_callback("mouseup", handler, action, cb_args="e", param_defn=get_event_params())
                         },
                         ## Do some low-level canvas interface and 
                         ## implement some convenience functions, ala R style
                         call_method =  function(context_method, ...) {
                           "Call a method of the context"
                           cmd <- sprintf("%s.%s(%s);",
                                          get_canvas_context(),
                                          context_method,
                                          process_dot_args(...)
                                          )
                           .self$add_js_queue(cmd)
                         },
                         ## repeat the above. to get shortcut
                         . =  function(context_method, ...) {
                           "Call a method of the context"
                           cmd <- sprintf("%s.%s(%s);",
                                          get_canvas_context(),
                                          context_method,
                                          process_dot_args(...)
                                          )
                           .self$add_js_queue(cmd)
                         },
                         set_property = function(property, value) {
                           "set property of context object"
                           cmd <- sprintf("%s.%s = %s;",
                                          get_canvas_context(),
                                          property,
                                          coerceToJSString(value))
                           add_js_queue(cmd)
                         },
                         set_styles = function(
                           lwd=NULL, lcol=NULL, lineJoin=NULL,
                           col = NULL, alpha=NULL, ...
                           ) {
                           "Set style properties"
                           ## Style properties fill, lwd, ......
                           if(!is.null(lwd))
                             set_property("lineWidth", lwd)
                           if(!is.null(lcol))
                             set_property("strokeStyle", ifelse(is.numeric(lcol),
                                                                sprintf("rbg(%s);", paste(lcol, collapse=",")),
                                                                lcol))
                           lineJoin <- getWithDefault(lineJoin, "miter")
                           set_property("lineJoin",lineJoin)
                           
                           if(!is.null(col))
                             set_property("fillStyle", ifelse(is.numeric(col),
                               sprintf("rbg(%s);", paste(col, collapse=",")),
                               col))
                           if(!is.null(alpha))
                             set_property("globalAlpha", alpha)
                         },
                         rrcycle = function(x, i) {
                           "Like x[i], but recycles and handles NULL"
                           if(is.null(x)) x
                           x[1 + (i-1) %% length(x)]
                         },
                         ## Write "R"-esque primitives. 
                         polygon = function(x, y=NULL,
                           ## XXX issue with col
                           lwd=1,       # line width, pixels
                           lcol=NULL,   # line color
                           alpha = 1,   # in [0,1]
                           col = NULL,  # fill color either c(R,G,B) or "#RGB"
                           ...) {
                           xy <- xy.coords(x, y)
                           n <- length(xy$x)
                           x <- c(xy$x, x[1]); y <- c(xy$y, y[1]) # append point to close

                           .("save")
                           set_styles(lwd=lwd, lcol=lcol, col=col, alpha=alpha)
                           
                           ## loop
                           .("beginPath")
                           for(i in seq_len(n)) {
                             .("moveTo",x[i], y[i]);
                             .("lineTo",x[i+1], y[i+1]);
                           }
                           ifelse(is.null(col),.("stroke"), .("fill"))
                           .("restore")
                         },
                         lines = function(x, y,
                           lwd=1,       # line width, pixels
                           lcol=NULL,   # line color
                           alpha = 1,   # in [0,1]
                           col = NULL,  # fill color either c(R,G,B) or "#RGB"
                           ...) {
                           "Draw lines"
                           xy <- xy.coords(x, y)
                           n <- length(xy$x)
                           x <- c(xy$x, x[1]); y <- c(xy$y, y[1]) # append point to close

                           .("save")
                           set_styles(lwd=lwd, lcol=lcol, col=col, alpha=alpha)
                           
                           .("beginPath")
                           for(i in seq_len(n)) {
                             if(!any(c(is.na(x[i]), is.na(y[i])))) {
                               .("moveTo",x[i], y[i]);
                               .("lineTo",x[i+1], y[i+1]);
                             }
                           }
                           .("stroke")
                           .("restore")
                         },
                         rect = function(xleft, ybottom, xright, ytop,
                           lwd=NULL, lcol=NULL, col=NULL, alpha=NULL,
                           ...) {
                           "Draw rectangles, vectorized. Rect in R is cartesian, in canvas (0,0) upper right"
                           rect_type <- ifelse(is.null(col), "strokeRect", "fillRect")
                           n <- length(xleft)

                           .("save")
                           
                           sapply(seq_len(n), function(i) {
                             .("beginPath")
                             set_styles(lwd=rrcycle(lwd,i), lcol=rrcycle(lcol,i),
                                        col=rrcycle(col, i), alpha=rrcycle(alpha,i))
                             .(rect_type, xleft[i], height - ytop[i],
                               abs(xright[i] - xleft[i]), abs(ytop[i] - ybottom[i]))
                             .("stroke")
                             .("restore")                             
                           })

                         },
                         circle = function(x, y=NULL, r, 
                           lwd=NULL, lcol=NULL, col=NULL, alpha=NULL,
                           ...) {
                           "Draw circles centered as (x,y) with radius r"
                           xy <- xy.coords(x, y)
                           n <- length(xy$x)
                           r <- rep(r, len=n)
                           .("save")
                           
                           ## loop
                           for(i in seq_len(n)) {
                             set_styles(lwd=rrcycle(lwd,i), lcol=rrcycle(lcol,i),
                                        col=rrcycle(col,i), alpha=rrcycle(alpha,i))
                             .("beginPath")
                             .("moveTo", x[i] + r[i], y[i])
                             .("arc", x[i], y[i], r[i], 0, 2*pi)
                             if(!is.null(rrcycle(col,i)))
                               .("fill")
                             else
                               .("stroke")
                             .("restore")                           
                           }
                         }
                         )
                       )
                     
                          
